# Binary Format

Mellivora encodes structs to it's own binary format. This allows for some partial decoding when
performing reads for performance.

For example, given the following struct:

```go
type DataNode struct {
    DataNodeId uint64 `m:"pk,serial"`
    Address    string `m:"unique:uq_address_port"`
    Port       int32  `m:"unique:uq_address_port"`
    User       string
    Password   string
    Healthy    bool
}
```

This will essentially tell Mellivora that this record should be stored by the primary key DataNodeId
and that the Id should be autogenerated if it is 0. It also tells the DB that the fields address and
port should be unique in the table. As in; there should not be another record with the same address
and port pair.

Mellivora is a columnar database and as such the DataNode record will be stored as several
individual records.

```
/datum/DataNode/{DataNodeId}
/datum/DataNode/{DataNodeId}/Address  = [Length Prefix]{Address Value}
/datum/DataNode/{DataNodeId}/Port     = {Port Value} # We don't need a length prefix for a static sized type.
/datum/DataNode/{DataNodeId}/User     = [Length Prefix]{User Value}
/datum/DataNode/{DataNodeId}/Password = [Length Prefix]{Password Value}
/datum/DataNode/{DataNodeId}/Healthy  = {Healthy Value}

/unique/DataNode/uq_address_port/[Address Length]{Address Value},{Port Value} = {DataNodeId}
```

When a new DataNode record is inserted it will make sure that the following key does not already
exist:

```
/datum/DataNode/{DataNodeId}
```

This will guarantee that the we do not get a primary key conflict, as well as store that that key
was read by the transaction; this way if that key gets inserted or changes before the current
transaction can commit then a conflict error will be returned to avoid overwriting the existing
record. However for completely new records this should not happen at all since the underlying store
Meles will generate a cluster-wide unique numeric Id for a record anyway. So no other node or thread
should be able to create the same record.

The other key that will be checked is the unique constraint key.

```
/unique/DataNode/uq_address_port/[Address Length]{Address Value},{Port Value}
```

This does the same thing as checking the primary key, it will make sure that it doesn't already
exist, but it also makes sure that a conflict error will be returned if that value changes before
we can commit.