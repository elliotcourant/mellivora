# Storage Format

Mellivora encodes structs to it's own storage format. This allows for some partial decoding when
performing reads for performance. This format is inspired directly by CockroachDB's underlying key
value implementation.

For example, given the following struct:

```go
type DataNode struct {
    DataNodeId uint64 `m:"pk,serial"`
    Address    string `m:"uq:uq_address_port"`
    Port       int32  `m:"uq:uq_address_port"`
    User       string
    Password   string
    Healthy    bool
}
```

This will essentially tell Mellivora that this record should be stored by the primary key DataNodeId
and that the Id should be autogenerated if it is 0. It also tells the DB that the fields address and
port should be unique in the table. As in; there should not be another record with the same address
and port pair.

Mellivora is a columnar database and as such the DataNode record will be stored as several
individual records.

```
/datum/DataNode/{DataNodeId}
/datum/DataNode/{DataNodeId}/Address  = [Length Prefix]{Address Value}
/datum/DataNode/{DataNodeId}/Port     = {Port Value} # We don't need a length prefix for a static sized type.
/datum/DataNode/{DataNodeId}/User     = [Length Prefix]{User Value}
/datum/DataNode/{DataNodeId}/Password = [Length Prefix]{Password Value}
/datum/DataNode/{DataNodeId}/Healthy  = {Healthy Value}

/unique/DataNode/uq_address_port/[Address Length]{Address Value},{Port Value} = {DataNodeId}
```

When a new DataNode record is inserted it will make sure that the following key does not already
exist:

```
/datum/DataNode/{DataNodeId}
```

This will guarantee that the we do not get a primary key conflict, as well as store that that key
was read by the transaction; this way if that key gets inserted or changes before the current
transaction can commit then a conflict error will be returned to avoid overwriting the existing
record. However for completely new records this should not happen at all since the underlying store
Meles will generate a cluster-wide unique numeric Id for a record anyway. So no other node or thread
should be able to create the same record.

The other key that will be checked is the unique constraint key.

```
/unique/DataNode/uq_address_port/[Address Length]{Address Value},{Port Value}
```

This does the same thing as checking the primary key, it will make sure that it doesn't already
exist, but it also makes sure that a conflict error will be returned if that value changes before
we can commit.

# Relations

Mellivora also supports relations. While only a single record type can be returned from a query, you
can still use relations and joins to filter the results of that record type allowing for some
natural distribution of data. Maybe at some point custom results could be returned.

Relations can be implemented in the following way:

```go
type Product struct {
    ProductId uint64 `m:"pk"`
    Title     string
}

type Variant struct {
    VariantId      uint64  `m:"pk"`
    ProductId      uint64
    ForeignProduct Product `m:"fk:ProductId"` // Provide the Id field(s) to be used.
    SKU            string  `m:"uq"`
}
```

Given a record for each of these, this serializes to something like this:

```
/datum/Product/{ProductId}
/datum/Product/{ProductId}/Title = [Length Prefix]{Title Value}

/datum/Variant/{VariantId}
/datum/Variant/{VariantId}/ProductId = {ProductId}
/datum/Variant/{VariantId}/SKU       = [Length Prefix]{SKU Value}

/unique/Variant/uq_variant_sku/[SKU Length]{SKU Value} = {VariantId}

/constraint/Product/{ProductId}/Variant/{VariantId}
```

This essentially introduces the constraint record. The constraint record is an additional key value
pair in the database that is used to make sure that dependant records will still exist if their
parent record is changed.

For example; if we were to try to delete the product record here, we would do a prefix scan on
constraints for products with that Id. If we find any records we can then start to handle the delete
behavior for that entity. If the delete behavior is restrict then we can immediately fail and return 
a restrict error. If the delete behavior is cascade then we now have a list of child records that
we need to also delete, and for each child record we delete we will also need to check if they have
any constraints. If the delete behavior is set null, then we can iterate over each of the items
and update their values for that relational field to be null.
At the moment Mellivora will only support the delete actions: _cascade_, _restrict_ and _set null_.

## Inserting with Relations

When a new record is inserted, like a Variant in the example above, we need to check for the
existence of the parent product record. We do this by verifying that the following key must in fact
exist.

```
/datum/Product/{ProductId}
```

If the value does not exist in the database then a foreign key violation error is returned.

## Reading with Relations

The big reason to use relations though is to read or filter data with them easily. We know a product
has variants, and we know a variant belongs to a product. Using the constraint record or primary
keys we can query these two records in either direction.

Lets say we wanted to get all the products that have a variant that has a SKU of `ABC123`. 
In SQL we would write this as:

```sql
SELECT 
    products.* 
FROM products 
INNER JOIN variants ON variants.product_id = products.product_id
WHERE
    variants.sku = 'ABC123';
```

With Mellivora this would written as:

```go
var products []Product{}
txn.Model(products).
    InnerJoin(Variant{}).
    Where(Ex{
        "Variant.SKU": "ABC123"
    }).
    Select(products)
```

Whats happening on the backend is we are basically doing a key-only full table scan on products with
the prefix:

```
/datum/Product/...
```

Each primary key record we hit we store to lookup the constraint record. We do not read any of the
column datums at this time. This results in an array of ProductIds that we can use.

We then have our iterator Seek to this prefix:

```
/constraint/Product/{ProductId}/Variant/...
```

This will essentially let us iterate over a list of every variant that references the current
product. For each variant we find we evaluate the expression if we can. In the example query we can
immediately evaluate the expression and can perform a direct GET on:

```
/datum/Variant/{VariantId}/SKU
```

If the key does not exist we continue on, if the key does exist then we do our comparison on the
value of the key. If the value matches our expression then we throw our current ProductId in a
bucket to be retrieved at the end of the operation.

On a side note: If we are limiting our results, the limit is evaluated here. So if we reach the
limit of records that we want to return it would stop evaluating the filter here and move on to
retrieving the actual data for the valid productIds. We also evaluate the offset here as well, if
the offset is greater than 0 then we only start throwing productIds into the bucket once we have
successfully found more productIds than the offset amount.

Once we have our final bucket of productIds we can now start to gather all of the data for their
records. This is a less efficient process because of the columnar nature of Mellivora while still
retrieving every column for a given record. However we know all of the fields for a given model; in
this case a Product, and we know all of the primary keys we want to read. So we can build the keys
desired from the store before we even start reading them. Once we have our array of keys we can
sort the keys and then use our iterator to seek to each key. This is probably the most efficient as
a GET operation uses iterators on the backend but must seek through the entire set to find a given
value (this is a bad explanation of how it really works), but with our iterator we can seek
sequentially for all of the keys we need and store their values and build our result.